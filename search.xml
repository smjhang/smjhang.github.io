<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title></title>
      <url>http://yoursite.com/2016/09/08/server-send-event/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis Notification]]></title>
      <url>http://yoursite.com/2016/07/27/redis-notification/</url>
      <content type="html"><![CDATA[<h1 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h1><p>在實現事件驅動設計的過程中，能夠讓資料庫在異動資料時自動發出通知是一個重要的環節，如此一來就不需要有另外一支程式不斷去查詢資料庫的異動，可以節省系統資源。<br>本篇探討將使用 redis 的 keyspace notification 功能來實現資料異動的即時通知，並且以 PHP 程式來實作。<br>本篇將會以一個線上購物網站的物品庫存清單為例，展示如何實作即時顯示當前貨品庫存量的功能。</p>
<h1 id="redis-資料結構規劃"><a href="#redis-資料結構規劃" class="headerlink" title="redis 資料結構規劃"></a>redis 資料結構規劃</h1><p>商品的資料儲存在 product:#id 的 hash，<br>並建立一個 set 用來維護商品清單。</p>
<table>
<thead>
<tr>
<th>data type</th>
<th>key</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>set</td>
<td>product_ids</td>
<td>商品總類清單</td>
</tr>
<tr>
<td>hash</td>
<td>product:#id</td>
<td>商品細節</td>
</tr>
</tbody>
</table>
<caption>表1: 資料結構規劃</caption>

<p><caption>建立 redis 資料</caption></p>
<pre><code>HMSET product:1 name &quot;多力多滋組合包-綜合 54g*4包/組&quot; price 55 stock 256
HMSET product:2 name &quot;【洋芋片】Lays樂事瑞士香濃起司 97g/包&quot; price 32 stock 179
HMSET product:3 name &quot;【蔓莓纖果】萬歲牌蔓莓纖果150G&quot;  price 59 stock 326
HMSET product:4 name &quot;【蒜香青豆】盛香珍蒜香青豆 240g/包&quot; price 42 stock 324
HMSET product:5 name &quot;【義美】義美小泡芙（檸檬風味）171g/盒&quot; price 64 stock 64
HMSET product:6 name &quot;【洋芋片】波的多超厚切洋芋片-蚵仔煎味&quot; price 53 stock 182
HMSET product:7 name &quot;【義美】義美小蛋卷（原味）&quot; price 49 stock 313
HMSET product:8 name &quot;品客碳烤BBQ口味洋芋片&quot; price 55 stock 158
SADD products 1
SADD products 2
SADD products 3
SADD products 4
SADD products 5
SADD products 6
SADD products 7
SADD products 8
</code></pre><h1 id="redis-keyspace-notification"><a href="#redis-keyspace-notification" class="headerlink" title="redis keyspace notification"></a>redis keyspace notification</h1><p>為了讓物品庫存數量能即時反應到應用程式，必須讓資料庫將資料的異動反應給應用程式，<br>這邊說明如何使用 redis 的 keyspace notification 功能來實現異動事件通知。<br>至於更詳細的說明可以看 <a href="http://redis.io/topics/notifications" title="Redis Keyspace Notifications" target="_blank" rel="external">官網說明文件</a>。</p>
<p>keyspace notification 可讓應用程式訂閱 keyspace 更動的事件，<br>當 redis 的資料有異動的時候有兩種類型的事件會被觸發：</p>
<ol>
<li>第一種讓我們可以監聽某個 key 是否被異動，當它被異動的時候，我們可以得知異動這個 key 的命令類型，稱為 keyspace 事件。</li>
<li>第二種讓我們可以監聽是否有某個命令類型被執行，當它被執行時，透過這個事件，我們可以得知被這個命令影響到的 key，稱為 keyevent 事件。</li>
</ol>
<p>Redis 的事件通知是透過 PUB/SUB 來進行的，因此再使用前需先了解 Redis PUB/SUB 是如何進行的。<br>可以參考官網的文件 <a href="http://redis.io/topics/pubsub" title="Redis PUB/SUB" target="_blank" rel="external">Redis PUB/SUB</a>。簡單來說就是一個客戶端訂閱了某個 channel, 另外一個客戶端可以發佈訊息到這個 channel,<br>然後前面那個訂閱的客戶端就可以收到第二個客戶端發送過來的訊息了。在 Redis keyspace notification 的應用中，Redis 會負責發佈訊息到指定的 channel, 我們只要接收這些訊息就可以了。<br>後面會討論這些 channel。</p>
<p>在使用 keyspace notification 前，需要先打開這個功能，編輯 redis.conf 將 notify-keyspace-events 設成：</p>
<pre><code>notify-keyspace-events &quot;KEA&quot;
</code></pre><p>根據官網的說明，<br>K - Keyspace events<br>E - Keyevent event<br>A - All commands<br>KEA 代表要訂閱所有命令類型的第一種和第二種事件。<br>更改設定檔要重啟 redis 後才會生效。</p>
<p>redis 的事件通知是透過 PUB/SUB 來進行的，因此當上述兩種事件發生的時候，redis 會分別發佈訊息到以下兩種 channel 上：</p>
<pre><code>1. PUBLISH __keyspace@&lt;db id&gt;__:&lt;key name&gt; &lt;command type&gt;
2. PUBLISH __keyevent@&lt;db id&gt;__:&lt;command type&gt; &lt;key name&gt; 
</code></pre><p>我們可以透過 PSUBSCRIBE 來訂閱這些事件：</p>
<pre><code>1. PSUBSCRIBE __keyspace@*__:*
2. PSUBSCRIBE __keyevent@*__:*
</code></pre><p>假設我們要觀察 del test1 test2 test3 test4 指令對 keyspace 和 keyevent 的影響可以分別訂閱以下兩個 channel</p>
<pre><code>127.0.0.1:6379&gt; PSUBSCRIBE __keyspace@*__:test*
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;
2) &quot;__keyspace@*__:test*&quot;
3) (integer) 1

127.0.0.1:6379&gt; PSUBSCRIBE __keyevent@*__:del
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;
2) &quot;__keyevent@*__:del&quot;
3) (integer) 1
</code></pre><p>設定要處理的 key</p>
<pre><code>127.0.0.1:6379&gt; set test1 test1
OK
127.0.0.1:6379&gt; set test2 test2
OK
127.0.0.1:6379&gt; set test3 test3
OK
127.0.0.1:6379&gt; set test4 test4
</code></pre><p>注意我這邊開了三個 terminal，分別執行三個 redis-cli，一個監聽對 test* 的異動，一個監聽 del 操作是否被執行，最後一個負責下各種指令。 </p>
<p>在建立過程中，可以看到對 keyspace 的監聽訊息如下：</p>
<pre><code>127.0.0.1:6379&gt; PSUBSCRIBE __keyspace@*__:test*
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;
2) &quot;__keyspace@*__:test*&quot;
3) (integer) 1
1) &quot;pmessage&quot;
2) &quot;__keyspace@*__:test*&quot;
3) &quot;__keyspace@0__:test1&quot;
4) &quot;set&quot;
1) &quot;pmessage&quot;
2) &quot;__keyspace@*__:test*&quot;
3) &quot;__keyspace@0__:test2&quot;
4) &quot;set&quot;
1) &quot;pmessage&quot;
2) &quot;__keyspace@*__:test*&quot;
3) &quot;__keyspace@0__:test3&quot;
4) &quot;set&quot;
1) &quot;pmessage&quot;
2) &quot;__keyspace@*__:test*&quot;
3) &quot;__keyspace@0__:test4&quot;
4) &quot;set&quot;
</code></pre><p>注意 <code>127.0.0.1:6379&gt; PSUBSCRIBE __keyevent@*__:del</code> 那個 redis-cli 沒有任何更新，因為沒有任何 del 操作被執行。<br>現在刪除 test, tests, test3, test4：</p>
<pre><code>127.0.0.1:6379&gt; del test1 test2 test3 test4
(integer) 4
</code></pre><p>可以看到對 keyspace (<code>127.0.0.1:6379&gt; PSUBSCRIBE __keyspace@*__:test*</code>) 的監聽如下：</p>
<pre><code>1) &quot;pmessage&quot;
2) &quot;__keyspace@*__:test*&quot;
3) &quot;__keyspace@0__:test1&quot;
4) &quot;del&quot;
1) &quot;pmessage&quot;
2) &quot;__keyspace@*__:test*&quot;
3) &quot;__keyspace@0__:test2&quot;
4) &quot;del&quot;
1) &quot;pmessage&quot;
2) &quot;__keyspace@*__:test*&quot;
3) &quot;__keyspace@0__:test3&quot;
4) &quot;del&quot;
1) &quot;pmessage&quot;
2) &quot;__keyspace@*__:test*&quot;
3) &quot;__keyspace@0__:test4&quot;
4) &quot;del&quot;
</code></pre><p>對 keyevent (<code>127.0.0.1:6379&gt; PSUBSCRIBE __keyevent@*__:del</code>)的監聽如下：</p>
<pre><code>1) &quot;pmessage&quot;
2) &quot;__keyevent@*__:del&quot;
3) &quot;__keyevent@0__:del&quot;
4) &quot;test1&quot;
1) &quot;pmessage&quot;
2) &quot;__keyevent@*__:del&quot;
3) &quot;__keyevent@0__:del&quot;
4) &quot;test2&quot;
1) &quot;pmessage&quot;
2) &quot;__keyevent@*__:del&quot;
3) &quot;__keyevent@0__:del&quot;
4) &quot;test3&quot;
1) &quot;pmessage&quot;
2) &quot;__keyevent@*__:del&quot;
3) &quot;__keyevent@0__:del&quot;
4) &quot;test4&quot;
</code></pre><p>從上面的結果我們可以知道一個命令對多個 key 的操作，是會引發多次 keyspace 事件和 keyevent 事件的。<br>然後我們透過這些事件只能知道是甚麼 key 被影響、被甚麼指令影響，而不知道 key 被異動後的資料，如果想要知道 key 的最新資料則要自己再去讀取那個 key。</p>
<h1 id="使用-Predis-在-PHP-中操作-redis"><a href="#使用-Predis-在-PHP-中操作-redis" class="headerlink" title="使用 Predis 在 PHP 中操作 redis"></a>使用 Predis 在 PHP 中操作 redis</h1><p>建立一個 redis-notify 專案</p>
<pre><code>mkdir redis-notofy
</code></pre><p>我們這邊使用 composer 來取得 Predis Async, 使用非同步版本的 Predis 比較適合這種監聽事件的任務。<br>關於 composer 的使用可以參考 <a href="https://getcomposer.org/" title="Composer" target="_blank" rel="external">composer 官網說明文件</a>。<br>關於 Predis Async 的介紹可以參考 <a href="https://packagist.org/packages/predis/predis" target="_blank" rel="external">Predis Async</a>。</p>
<p>在該專案內建立 composer.json 如下：</p>
<pre><code>{
  &quot;require&quot;:{&quot;predis/predis-async&quot;:&quot;dev-master&quot;}
}
</code></pre><p>執行 <code>composer install</code> 來從 Packagist 下載 Predis-Async</p>
<pre><code>compsoer install
</code></pre><p>可以開始用 Predis 了，編輯程式檔 notify.php 如下：</p>
<pre><code>&lt;?php
require __DIR__.&apos;/vendor/autoload.php&apos;;

class LocalStorage
{
    private $product_store = []; // 目前所有 products

    /**
     * 使用前更新目前所有 products
     * @param \Predis\Client $client_sync
     */
    public function init(\Predis\Client $client_sync)
    {
        $all_product_keys = $client_sync-&gt;keys(&apos;product:*&apos;);
        foreach ($all_product_keys as $product_key) {
            // 抓取 id
            preg_match(&apos;/product:(\d+)/&apos;, $product_key, $matches);
            $id = $matches[1];
            // 設定 id=&gt;product 關聯
            $this-&gt;product_store[$id] = $client_sync-&gt;hgetall($product_key);
        }
        // 排序 product_store
        ksort($this-&gt;product_store);
    }

    /**
     * 判斷 id 是否在 product_store 內
     * @param $id
     * @return bool
     */
    public function contains($id)
    {
        if (isset($this-&gt;product_store[$id])) {
            return true;
        }
        return false;
    }


    /**
     * 處理新增事件
     * @param $id
     * @param $product
     */
    function insertHandler($id, $product)
    {
        echo &quot;新增 product_store 項目:\n&quot;;
        echo &quot;id: $id\n&quot;;
        echo &quot;name: {$product[&apos;name&apos;]}\n&quot;;
        echo &quot;price: {$product[&apos;price&apos;]}\n&quot;;
        echo &quot;stock: {$product[&apos;stock&apos;]}\n\n&quot;;
        $this-&gt;product_store[$id] = $product;
    }


    /**
     * 處理更改事件
     * @param $id
     * @param $product
     */
    function updateHandler($id, $product)
    {
        echo &quot;更改 product_store 項目:\n&quot;;
        echo &quot;id: $id\n&quot;;
        if ($this-&gt;product_store[$id][&apos;name&apos;] !== $product[&apos;name&apos;]) {
            echo &quot;name: {$product[&apos;name&apos;]}\n&quot;;
            $this-&gt;product_store[$id][&apos;name&apos;] = $product[&apos;name&apos;];
        }
        if ($this-&gt;product_store[$id][&apos;price&apos;] !== $product[&apos;price&apos;]) {
            echo &quot;price: {$product[&apos;price&apos;]}\n&quot;;
            $this-&gt;product_store[$id][&apos;price&apos;] = $product[&apos;price&apos;];
        }
        if ($this-&gt;product_store[$id][&apos;stock&apos;] !== $product[&apos;stock&apos;]) {
            echo &quot;stock: {$product[&apos;stock&apos;]}\n&quot;;
            $this-&gt;product_store[$id][&apos;stock&apos;] = $product[&apos;stock&apos;];
        }
        echo &quot;\n&quot;;
    }

    /**
     * 處理刪除事件
     * @param $id
     * @param $product
     */
    function deleteHandler($id, $product)
    {
        echo &quot;刪除 product_store 項目:\n&quot;;
        echo &quot;id: $id\n\n&quot;;
        unset($this-&gt;product_store[$id]);
    }

    /**
     * 顯示 product_store
     */
    function showStore()
    {
        foreach ($this-&gt;product_store as $id =&gt; $product) {
            echo &quot;id: $id\n&quot;;
            echo &quot;name: {$product[&apos;name&apos;]}\n&quot;;
            echo &quot;price: {$product[&apos;price&apos;]}\n&quot;;
            echo &quot;stock: {$product[&apos;stock&apos;]}\n&quot;;
            echo &quot;----------------------------------------------\n&quot;;
        }
    }

}

$client = new Predis\Async\Client(&apos;tcp://127.0.0.1:6379&apos;);
$client_sync = new Predis\Client(&apos;tcp://127.0.0.1:6379&apos;);

$local_storage = new LocalStorage();
$local_storage-&gt;init($client_sync);
$local_storage-&gt;showStore();


/**
 * 註冊處理 keyspace 異動的事件，並根據事件的訊息做相應的處理
 */
$client-&gt;connect(function ($client) use ($client_sync, $local_storage) {
    // 使用 psubscribe 訂閱 product:#id 這種樣式的 key 被異動的事件
    $client-&gt;pubSubLoop([&apos;psubscribe&apos;=&gt;&apos;__keyspace@*__:product:*&apos;],
    function ($event, $pubsub) use ($client_sync, $local_storage) {
        // 當 product:#id 被異動的時候，根據事件發生的 channel 的名稱取得 key 的名稱和 product 的 id
        if (preg_match(&apos;/__keyspace@\d+__:(product:(\d+))/&apos;, $event-&gt;channel, $matches)) {
            $product_key = $matches[1];
            $product_id = $matches[2];
            // 取得被異動後，最新的 product 資料
            $product = $client_sync-&gt;hgetall($product_key);
            // 根據事件傳來的訊息得知操作 key 的類型
            $op = $event-&gt;payload;
            if ($op === &apos;del&apos;) {
                $local_storage-&gt;deleteHandler($product_id, $product);
            } else if ($op === &apos;hset&apos;) {
                // 當操作類型是 hset 的時候，需要從目前的 product store 去判斷是新增還是修改
                if ($local_storage-&gt;contains($product_id)) {
                    $local_storage-&gt;updateHandler($product_id, $product);
                } else {
                    $local_storage-&gt;insertHandler($product_id,$product);
                }
            }
        }
    });
});
// 開始監聽 keyspace 異動事件
$client-&gt;getEventLoop()-&gt;run();
</code></pre><p>這個程式維護一個本地的商品清單，並且隨時接收 redis 的最新異動來更新本地清單。<br>首先先建立一個 LocalStorage 物件來管理本地商品清單的增刪查改。<br>然後使用 Predis Async 來訂閱所有關於 product：* 的異動，<br>redis 的 keyspace notification 對要監聽的每個 key 都建立一個 channel<br>要訂閱的 channel 樣式如下：</p>
<pre><code>__keyspace@*__:product:*
</code></pre><p>然後當資料異動事件發生的時候，可以取得 channel 的名稱和從 channel 傳遞過來的訊息：</p>
<pre><code>channel 的名稱： __keyspace@0__:product:1
channel 的訊息： hset
</code></pre><p>因此我們可以從 channel 的名稱取得被異動的 key 的名稱 product:1，當然也可以只取得部份的 key 名稱 1，來作為 id。<br>然後可以從 channel 傳遞過來的訊息得知是甚麼操作異動了 key，這裡是 hset。<br>關於各種類型的操作會傳遞甚麼訊息可以查看官網的說明 <a href="http://redis.io/topics/notifications" title="Redis Keyspace Notifications" target="_blank" rel="external">官網說明文件</a>。<br>詳細的程式可以在 <a href="https://github.com/smjhang/demos" target="_blank" rel="external">我的 github 上的 demos 專案</a> 下載，放在 redis-notify 資料夾內。</p>
<p>執行程式可以看到以下結果：</p>
<pre><code>simon@simon:~/demos/redis-notify$ php notify.php 
id: 1
name: 多力多滋組合包-綜合 54g*4包/組
price: 55
stock: 256
----------------------------------------------
id: 2
name: 【洋芋片】Lays樂事瑞士香濃起司 97g/包
price: 32
stock: 179
----------------------------------------------
id: 3
name: 【蔓莓纖果】萬歲牌蔓莓纖果150G
price: 59
stock: 326
----------------------------------------------
id: 4
name: 【蒜香青豆】盛香珍蒜香青豆 240g/包
price: 42
stock: 324
----------------------------------------------
id: 5
name: 【義美】義美小泡芙（檸檬風味）171g/盒
price: 64
stock: 64
----------------------------------------------
id: 6
name: 【洋芋片】波的多超厚切洋芋片-蚵仔煎味
price: 53
stock: 182
----------------------------------------------
id: 7
name: 【義美】義美小蛋卷（原味）
price: 49
stock: 313
----------------------------------------------
id: 8
name: 品客碳烤BBQ口味洋芋片
price: 55
stock: 158
----------------------------------------------
</code></pre><p>另外開一個 redis client 來異動資料：</p>
<pre><code>simon@simon:~/demos$ redis-cli
127.0.0.1:6379&gt; HMSET product:9 name &apos;旺旺 仙貝經濟包&apos; price 469 stock 79
OK
127.0.0.1:6379&gt; HMSET product:9 name &apos;旺旺 仙貝經濟包&apos; price 469 stock 75
OK
127.0.0.1:6379&gt; DEL product:9
(integer) 1
127.0.0.1:6379&gt; 
</code></pre><p>可以在 notify.php 的輸出畫面看到新的訊息：</p>
<pre><code>新增 product_store 項目:
id: 9
name: 旺旺 仙貝經濟包
price: 469
stock: 79

更改 product_store 項目:
id: 9
stock: 75

刪除 product_store 項目:
id: 9
</code></pre><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>這邊介紹 redis 如何實現資料異動通知的功能。不過要注意的是 redis 不會保存通知過的訊息，因此如果對 redis 的連線斷線的話，斷線的應用程式是無法再取得斷線期間的異動通知。<br>如果非常在意事件一定要通知到的話，要自己想辦法把事件保留起來，官網上說未來 redis 可能會將這些通知保留再另外的 SET 內，不過現階段還沒有，可能要自己實作保存事件的部份。</p>
]]></content>
    </entry>
    
  
  
</search>
